<?php
namespace Bauplan\Compiler;

use Bauplan\Exception\SyntaxError as SyntaxError;

/*
 * A stream of tokens generated by the lexer and sent to the parser. A stream is
 * associated with a Bauplan source file
 *
 * Adapted from the Symfony project
 */
class TokenStream {
  private $current;
  private $tokens;
  private $position;
  private $file;

  function __construct($tokens, $file=null) {
    $this->tokens = $tokens;
    $this->current = $tokens[0];
    $this->position = 0;
    $this->file = $file;
  }

  function setFile($file) {
    $this->file = $file;
  }

  function getCurrent() {
    return $this->current;
  }

  function getFile() {
    return $this->file;
  }

  function hasNext() {
    return isset($this->tokens[$this->position]);
  }

  /*
   * Return the next token in the stream if one exists or throw an exception if
   * the end of the stream has been reached
   */
  function next() {
    if (!$this->hasNext()) {
      throw new SyntaxError("Unexpected end of expression", $this->current->getCursor(), $this->file);
    }

    $this->current = $this->tokens[++$this->position];
    return $this->current;
  }

  /*
   * In fatal mode: Throws a syntax error if an unexpected token is encountered
   * In regular mode: Returns true or false depending on whether the expected
   * token is found
   */
  function expect($type, $optionalOrMessage=null) {
    $returnVal;
    if ($optionalOrMessage === null) {
      $returnVal = $this->expectOptional($type);
    }
    else {
      $returnVal = $this->expectFatal($type, $optionalOrMessage);
    }

    if ($returnVal !== false) $this->next();
    return $returnVal;
  }

  function expectOneOf($types, $optionalOrMessage=null) {
    $current = $this->current;
    if ($current->oneOf($types)) {
      $this->next();
      return $current;
    }
    if ($optionalOrMessage) {
      throw new SyntaxError(sprintf('%sUnexpected type "%s" with value "%s" (expected "%s %s") at line %d in file %s', $message ? $message . '. ' : '', $token->getType(), $token->getValue(), $type, $value, $token->getCursor(), $this->file));
    }
    return false;
  }

  /*
   * Return whether or not the expected type was matched
   */
  private function expectOptional($type) {
    $current = $this->current;
    return $current->compareType($type) ? $current : false;
  }

  /*
   * Throw error on unexpected token type
   */
  private function expectFatal($type, $message) {
    $token = $this->current;
    if (!$token->compareType($type)) {
      throw new SyntaxError(sprintf('%sUnexpected type "%s" with value "%s" (expected "%s") at line %d in file %s', $message ? $message . '. ' : '', $token->getType(), $token->getValue(), $type, $token->getCursor(), $this->file));
    }
    return $token;
  }

}

?>
