<?php
namespace Bauplan\Compiler;

/*
 * A stream of tokens generated by the lexer and sent to the parser. A stream is
 * associated with a Bauplan source file
 *
 * Adapted from the Symfony project
 */
class TokenStream {
  private $current;
  private $tokens;
  private $position;
  private $file;

  function __construct($tokens, $file=null) {
    $this->tokens = $tokens;
    $this->current = $tokens[0];
    $this->position = 0;
    $this->file = $file;
  }

  function getCurrent() {
    return $this->current;
  }

  function getFile() {
    return $this->file;
  }

  function hasNext() {
    return isset($this->tokens[$this->position]);
  }

  function next() {
    if (!$this->hasNext()) {
      throw new SyntaxError("Unexpected end of expression", $this->current->getCursor(), $this->file);
    }

    $this->position++;
    $this->current = $this->tokens[$this->position];
  }

  function expect($type, $value, $optionalOrMessage=null) {
    if ($optionalOrMessage === false) {
      return $this->expectOptional($type, $value);
    }
    else {
      return $this->expectFatal($type, $value, $optionalOrMessage);
    }
  }

  /*
   * Return whether or not the expected type was matched
   */
  private function expectOptional($type, $value) {
    if (!$token->test($type, $value)) {
      return false;
    }
    $this->next();
    return true;
  }

  /*
   * Throw error on unexpected token type
   */
  private function expectFatal($type, $value, $message) {
    $token = $this->current;
    if (!$token->test($type, $value)) {
      throw new SyntaxError(sprintf('%sUnexpected token "%s" of value "%s" ("%s" expected%s)', $message ? $message . '. ' : '', $token->getType(), $token->getValue(), $type, sprintf(' with value "%s"', $value)), $token->getCursor(), $this->file);
    }
    $this->next();
  }
}

?>
